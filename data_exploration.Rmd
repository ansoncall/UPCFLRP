---
title: "UPCFLRP Data Exploration"
author: "Anson Call"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(kableExtra)
library(ggpubr)
```

# Overview
While the broad goals of this project are outlined more completely in the [draft manuscript](https://cfri.app.box.com/file/1801500191498?s=j11vyr3c60lq4yxhi149anjlz9o1worc), the specific goals addressed here are to quantify treatment-associated changes in basal area, trees per acre, quadratic mean diameter (QMD), and species composition
- by treatment type (e.g., thinning, burning, etc.)
- by treatment intensity
- by treatment age or phase (e.g., 2-5 years post-treatment, 5-10 years post-treatment, etc.)
- by elevation and forest type (e.g., by unit)

# Concerns with specific plots

## Summary of pre-existing concerns

From Maggie's [Notes for (future) 2024 Data Analysis_MKP.docx](https://cfri.app.box.com/file/1445776069418):

> Lockhart plots might have overstory issues, it seems like some of them (L12, L23, L25, L13, L24 and L27) appear to have a DBH cutoff at 7.5-8 inch DBH in the PRE entry, but then show a large number of trees under 8 inches in DBH in post1 or post 5-6

> Be careful with plot 9D, some trees names RA9D, which I replaced with 9D for now but it’s possible they were duplicates.

In addition, the following 2013 plot visits are marked as "partial plots" in the ["UP-CFLRP All Plot Notes.docx"](https://cfri.app.box.com/file/1506842133331) 

```{r plots-marked-partial, echo=FALSE}
plots_marked_partial <- c("L12", "L13", "L23", "L24", "L25", "L27", "RA1510")
cat("Plots marked partial\n", plots_marked_partial)
```

The following two 2013 plot visits were marked with the note:

> Dropped in favor of 2015 pre

```{r additional-marked-plots, echo=FALSE}
addl_plots <- c("L29", "L8")
cat("Additional marked plots:\n", addl_plots)
```

## Confirming issues and identifying new ones

### Half-plots
From the [plot mapper](https://reshapewildfire.shinyapps.io/UPCFLRP_plot_mapper/), we can identify sites that have very high variation between visits. The following plots have a high coefficient of variation and a plot map suggesting that only half-plots were recorded on one or more visits:


```{r plot-mapper-problem-plots, echo=FALSE}
half_plots <- c(
  "RA1310", # confirmed half plot PRE_1
  "RA710" # confirmed half plot POSTRX_1
  )

ntrees <- read.csv("ntrees.csv")
ntrees %>%
  filter(id %in% half_plots)
```

The following plot is not exactly a half-plot, but it's clear there is some incompleteness in the southeast quadrant:

```{r plot-mapper-problem-plots-continued, echo=FALSE}
partial_plots <- c(
  "RA2040" # missing trees in SE quadrant of POSTRX_1
  )

ntrees <- read.csv("ntrees.csv")
ntrees %>%
  filter(id %in% partial_plots)
```

### Other issues
#### Inconsistent DBH thresholds

**Update 9/4/2025: DBH cutoff of >= 8 has been implemented. This section can now be ignored**

The following plots do not have evidence of the "half-plot" problem, but do have a high coefficient of variation, possibly because the lower DBH threshold for recording trees was not consistent across visits, as noted by Maggie:

```{r plot-mapper-problem-plots-continued_2, echo=FALSE}
addl_high_cv_plots <- c(
  "L29", "L7", "RA178", "L23", "3A", "RA181", "L8", "L9", "L27", "L25", "L11", 
  "RA281", "L10", "RA410", "L12", "L13", "L24"
)

ntrees <- read.csv("ntrees.csv")
ntrees %>%
  filter(coef_variation > 0.2)
```

This list includes all of the plots identified by Maggie (L12, L23, L25, L13, L24 and L27) and adds 11 new ones. These new plots are not only from the "L" area. 

This problem of inconsistent lower DBH thresholds is most pronounced in these plots, but it actually seems like it could be *a problem in most, if not all* plots. 

We can examine this directly by checking the lower bounds of the DBH distribution for each plot and visit. We'll check the absolute minimum DBH and the 2.5th percentile of the DBH distribution for recorded trees at each plot and visit. Then, we can look for plots where the gap between these values on successive visits is large. 

```{r dbh-lower-bounds, message=FALSE, warning=FALSE}
overstory <- read_csv("overstory_tidy.csv")

min_dbh_change <- overstory %>%
  group_by(id, t_idxn) %>%
  summarise(
    min_dbh = min(dbh, na.rm = TRUE),
    p2_5_dbh = quantile(dbh, 0.025, na.rm = TRUE)
  ) %>%
  arrange(id, t_idxn) %>% 
  pivot_wider(
    names_from = t_idxn,
    values_from = c(min_dbh, p2_5_dbh)
  ) %>% 
  rowwise %>% 
  mutate(
    # What is the largest gap between the minimum DBH of the PRE_1 visit and all
    # POST_* visits?
    min_dbh_gap_PRE_1 = max(c_across((matches("^min_.*POST"))), na.rm = TRUE) - 
      min_dbh_PRE_1,
    # What is the largest gap between the minimum DBH of the PRE_2 visit and all
    # POST_* visits?
    min_dbh_gap_PRE_2 = max(c_across((matches("^min_.*POST"))), na.rm = TRUE) - 
      min_dbh_PRE_2,
    # same, but for 2.5%
    p2_5_dbh_gap_PRE_1 = max(c_across((matches("^p2_5_.*POST"))), na.rm = TRUE) - 
      p2_5_dbh_PRE_1,
    p2_5_dbh_gap_PRE_2 = max(c_across((matches("^p2_5_.*POST"))), na.rm = TRUE) - 
      p2_5_dbh_PRE_2
  ) %>% 
  filter(!all(is.na(val <- c_across(contains("gap"))) | val == -Inf)) %>%
  ungroup %>% 
  arrange(min_dbh_gap_PRE_1) %>% 
  mutate(row_highlight = id %in% addl_high_cv_plots,
         row_num = row_number())  # needed for row_spec()

min_dbh_change %>% 
  select(id, matches("gap"), starts_with("min"), starts_with("p2_5_")) %>% 
  kbl() %>%
  kable_paper() %>%
  column_spec(2:3, background = "#A1D5FF7F") %>% 
  column_spec(4:5, background = "#C7F9FF7F") %>% 
  row_spec(which(min_dbh_change$row_highlight), bold = TRUE) %>% 
  scroll_box(width = "100%", height = "300px")
```

It seems that the problems are all localized to PRE_1 visits. There isn't a big gap between the minimum values of the PRE_2 visits and any of the POST* visits. The problem plot values are bolded here, and you can see they are concentrated at the top of the table. That means a lot of the issue could be explained away by this gap in the size of trees that are being recorded.

Plot L7 is a big offender here:

```{r l7, echo=FALSE}
mins <- overstory %>% 
  filter(id == "L7") %>% 
  group_by(t_idxn) %>% 
  summarize(min = min(dbh))
overstory %>% 
  filter(id == "L7") %>% 
  ggplot(aes(x = dbh, fill = t_idxn)) +
  geom_histogram(alpha = 0.4, position = "identity") +
  geom_vline(xintercept = mins[[1, 2]], color = scales::hue_pal()(3)[1]) +
  geom_vline(xintercept = mins[[2, 2]], color = scales::hue_pal()(3)[2]) +
  geom_vline(xintercept = mins[[3, 2]], color = scales::hue_pal()(3)[3]) +
  labs(title = "Histogram of DBH values for plot L7, three total visits", 
       sub = "lines show minimum recorded dbh value")

```

Plotting histograms for all of the worst offenders **(watch out for changes in the color scales)**:

<div style="max-height: 600px; overflow-y: auto; width: 100%; border: 1px solid #ccc; padding: 10px;">
```{r dbh_histograms, echo=FALSE, results='hide', message=FALSE, warning=FALSE, class.source="scroll-800"}
# define plotting function
mk_dbh_hist <- \(ID, df) {
  mins <- df %>% 
    filter(id == ID) %>% 
    group_by(t_idxn) %>% 
    summarize(min = min(dbh))
  n_idxn <- nrow(mins)
  plot <- df %>% 
    filter(id == ID) %>% 
    ggplot(aes(x = dbh, fill = t_idxn)) +
    geom_histogram(alpha = 0.4, position = "identity") +
    geom_vline(xintercept = mins[[1, 2]], 
               color = scales::hue_pal()(n_idxn)[1]) +
    geom_vline(xintercept = mins[[2, 2]], 
               color = scales::hue_pal()(n_idxn)[2]) +
    labs(title = paste0("Histogram of DBH values for plot ",
                        ID,
                        " ",
                        n_idxn,
                        " total visits"), 
         sub = "lines show minimum recorded dbh value")
  if (n_idxn > 2) {
    plot <- plot + geom_vline(xintercept = mins[[3, 2]], 
                              color = scales::hue_pal()(n_idxn)[3])
  }
  if (n_idxn > 3) {
    plot <- plot + geom_vline(xintercept = mins[[4, 2]], 
                              color = scales::hue_pal()(n_idxn)[4]) 
  }
  return(plot)
}

# get ids to plot over
big_gaps <- min_dbh_change %>% 
  filter(min_dbh_gap_PRE_1 < -0.1) %>% 
  pull(id)
# make plots
plots <- map(big_gaps, \(x) mk_dbh_hist(x, overstory))
# arrange plots in scroll box
plots
```
</div>

A practical solution to this problem would be to _remove trees below the highest dbh threshold_ for plots where this seems to be an issue. 

```{r apply-cutoff}

overstory_min8 <- overstory %>% 
  filter(dbh >= 8)

data_loss <- (1 - nrow(overstory_min8) / nrow(overstory)) * 100

cat(round(data_loss, 2), "% of trees removed by DBH cutoff", sep = "")

```
Now, let's revisit the CV values for tree counts and see if some of these sites start to look less extreme.

```{r post-dbh-cv}
# ntrees data
ntrees_min8 <- overstory_min8 %>%
  group_by(id, t_idxn) %>%
  summarise(ntrees = n(), .groups = "keep") %>%
  ungroup() %>%
  pivot_wider(names_from = t_idxn, values_from = ntrees) %>%
  rowwise %>%
  mutate(mean = mean(c_across(starts_with("P")), na.rm = TRUE),
         sd = sd(c_across(starts_with("P")), na.rm = TRUE),
         coef_variation = ifelse(mean == 0, NA, sd / mean)) %>%
  select(id, starts_with("PRE"), starts_with("POST_"), starts_with("POSTRX"),
         mean, coef_variation) %>%
  arrange(desc(coef_variation)) %>% 
  ungroup %>% 
  mutate(cv_rank_new = row_number()) %>% 
  left_join(ntrees %>% 
              mutate(cv_rank_old = row_number(),
                     coef_variation_old = coef_variation) %>% 
              select(id, cv_rank_old, coef_variation_old), 
            by = "id") %>% 
  relocate(starts_with("cv_"), starts_with("coef_"), .before = PRE_1) %>% 
  arrange(cv_rank_old)

ntrees_min8 %>%
  kbl() %>%
  kable_paper() %>%
  column_spec(2:3, background = "#A1D5FF7F") %>% 
  column_spec(4:5, background = "#C7F9FF7F") %>% 
  row_spec(which(min_dbh_change$row_highlight), bold = TRUE) %>% 
  scroll_box(width = "100%", height = "800px") 
  

```

Okay, it looks like this correction clearly made a difference for some plots, particularly the `L` plots. The `RA` plot CVs are less affected. Let's glance at some histograms pre- and post-application of the DBH cutoff. 

<div style="max-height: 600px; overflow-y: auto; width: 100%; border: 1px solid #ccc; padding: 10px;">
```{r pre-post-histograms}
# define key plots: top 10 of ntrees_min8
key_plots <- ntrees_min8$id[1:10]
# map over key plots to make list of old plots
old_hists <- map(key_plots, \(x) mk_dbh_hist(x, overstory) + 
                   labs(subtitle = "OLD"))
new_hists <- map(key_plots, \(x) mk_dbh_hist(x, overstory_min8) + 
                   labs(subtitle = "NEW"))

dual_plot <- \(x, y) {
  plots <- list(x, y)
  p <- ggarrange(x, y, nrow = 2)
  p
}
dual_plot(old_hists[[1]], new_hists[[1]])
# plot old and new hists side-by-side
plots <- map2(old_hists, new_hists, \(x, y) dual_plot(x, y))
plots
```
</div>

#### Possible aspen regen

Though the DBH cutoff certainly helped, there are still some suspect cases of dramatically increasing tree counts in the post-treatment visits. One possible explanation is aspen regeneration. Let's see if aspen are frequent at any of the high-CV sites. 

```{r prop-aspen}

aspen_df <- overstory_min8 %>%
  group_by(id, species) %>%
  summarise(ntrees = n(), .groups = "keep") %>%
  ungroup() %>%
  pivot_wider(names_from = species, values_from = ntrees) %>%
  rowwise %>%
  mutate(aspen_proportion = POTR5 / sum(across(PIPO:last_col()), 
                                        na.rm = TRUE)) %>% 
  select(id, aspen_proportion)

out <- ntrees_min8 %>%
  left_join(aspen_df, by = "id") %>% 
  relocate(aspen_proportion, .before = everything()) %>% 
  arrange(cv_rank_new) %>% 
  mutate(aspen_perc_rank = percent_rank(aspen_proportion), .before = id)

out %>% 
  kbl() %>%
  kable_paper() %>%
  column_spec(1:2, background = "#A1D5FF7F") %>% 
  column_spec(4, background = "#C7F9FF7F") %>% 
  row_spec(which(out$aspen_perc_rank > 0.75), bold = TRUE) %>% 
  scroll_box(width = "100%", height = "800px") 

high_aspen <- out %>% filter(aspen_proportion >= 0.3) %>% pull(id)
  
```

# Stump data
  
Many plots have stump data, but only a few specific plots have stump data that was specifically collected in an effort to recreate data from earlier site visits where data collection may have been incomplete.

Here, we review which plots have stump data and highlight the ones that we specifically need to take a closer look at. None of these were tagged as half- or partial-plots, though some do have potential aspen regen. 

```{r stump-dbh, echo=FALSE}

# plots specifically identified by marin as having "reconstruction" stump data
reconstruction_plots <- c("L12",
                          "L27",
                          "L7",
                          "L9",
                          "RA178",
                          "RA281",
                          "9A",
                          "9B",
                          "9D",
                          "3A",
                          "RA2540",
                          "RA1110",
                          "RA1410",
                          "RA610",
                          "RA2010")
reconstruction_plots %>% 
  as_tibble %>%
  set_names("id") %>% 
    kbl() %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "800px") 



test <- overstory %>%
  group_by(id, t_idxn) %>%
  summarise(ntrees = n(), .groups = "keep") %>%
  ungroup() %>%
  pivot_wider(names_from = t_idxn, values_from = ntrees) %>%
  rowwise %>%
  mutate(mean = mean(c_across(starts_with("P")), na.rm = TRUE),
         sd = sd(c_across(starts_with("P")), na.rm = TRUE),
         coef_variation = ifelse(mean == 0, NA, sd / mean)) %>%
  select(id, starts_with("PRE"), starts_with("POST_"), starts_with("POSTRX"),
         mean, coef_variation) %>%
  arrange(desc(coef_variation)) %>% 
  ungroup %>% 
  filter(id %in% reconstruction_plots) %>% 
  mutate(notes = case_when(
    id %in% high_aspen ~ ">30% aspen",
    .default = ""
  ))

test %>%
  kbl() %>%
  kable_paper() %>%
  row_spec(which(test$coef_variation >= 0.2), bold = TRUE) %>% 
  scroll_box(width = "100%", height = "800px") 
  
```

Only ~4 of these plots actually have weird values, and of those 2 have a major aspen component.  

Though, note that the following plots also have stump data from 2024. Are we sure we don't want to look at these as well?

```{r stump-dbh-2, echo=FALSE}

`%ni%` <- Negate(`%in%`)

out2 <- overstory %>% 
  filter(status == "S" & !is.null(dbh) & date > as.POSIXct("2024-01-01 00:00:00")) %>%
  select(id) %>% 
  arrange(id) %>% 
  unique() %>%
  filter(id %ni% reconstruction_plots)

out2 %>% 
  kbl() %>%
  kable_paper() %>%
  row_spec(which(out2$t_idxn == "PRE_1" | out2$t_idxn == "PRE_2"), background = "#C7F9FF7F") %>% 
  scroll_box(width = "100%", height = "800px") 

```

## Plotting stump data

Let's look closely at RA178, which is seemingly where the biggest problem lies. The PRE_1 count was exceptionally low.

Uh oh - problem. The 2024 "reconstruction" visit does not include the locations of any recorded trees. It only includes the quadrant. This means we can't actually plot out the locations to see whether

!["RA178 raw datasheet"](./images/RA178_2024_datasheet.png)

What about other plots?

3A:

!["3A raw datasheet"](./images/3A_2024_datasheet.png)

Wait, do we have *any* 2024 data for the plots in question??

```{r stump-dbh-2, echo=FALSE}

out2 <- overstory %>% 
  filter(status == "S" & !is.null(dbh) & date > as.POSIXct("2024-01-01 00:00:00")) %>%
  select(id) %>% 
  arrange(id) %>% 
  unique() %>%
  filter(id %in% reconstruction_plots)

out2 %>% 
  kbl() %>%
  kable_paper() %>%
  row_spec(which(out2$t_idxn == "PRE_1" | out2$t_idxn == "PRE_2"), background = "#C7F9FF7F") %>% 
  scroll_box(width = "100%", height = "800px") 

```



Okay, just two plots of the original 15. We can look at those, at least. And for the others, we can look at total tree counts and see if they are way off:

# TODO do this comparison quadrant by quadrant count, not by total site visit count. Need to see if there is a specific quadrant where data is missing. Remember, the "reconstruction" data is missing specific coordinates, so the best we can do is to check the quadrant by quadrant counts. if everything is okay, we should see similar counts in pre- and post- data when we look at large trees/stumps specifically--these were probably unaffected by any treatment or fire (or if they were affected, they were at least recorded as stumps in the "reconstruction" visit). 


```{r reconstruction_quadrants}
overstory_r <- read_csv("overstory_tidy_reconstruction.csv")
nrow(overstory)
nrow(overstory_r)
glimpse(overstory_r)
which_visit <- overstory_r %>% 
  filter(id %in% reconstruction_plots,
         date >= as.POSIXct("2024-01-01")) %>%
  group_by(id, t_idxn) %>% 
  summarise(ntrees = n(), .groups = "keep") %>%
  ungroup() %>% 
  select(id, which_visit = t_idxn) %>% arrange(id)
  
overstory_r %>% 
  filter(species != "POTR5") %>% 
  filter(id %in% reconstruction_plots) %>%
  group_by(id, t_idxn, status) %>%
  summarise(ntrees = n(), .groups = "keep") %>%
  ungroup() %>%
  pivot_wider(names_from = c(t_idxn, status), values_from = ntrees) %>%
  rowwise %>%
  mutate(mean = mean(c_across(starts_with("P")), na.rm = TRUE),
         sd = sd(c_across(starts_with("P")), na.rm = TRUE),
         coef_variation = ifelse(mean == 0, NA, sd / mean)) %>%
  select(id, starts_with("PRE"), starts_with("POST_"), starts_with("POSTRX"),
         mean, coef_variation) %>%
  arrange(desc(coef_variation)) %>% 
  ungroup %>% 
  filter(id %in% reconstruction_plots) %>% 
  mutate(notes = case_when(
    id %in% high_aspen ~ ">30% aspen",
    .default = ""
  )) %>% 
  left_join(which_visit) %>% 
  kbl() %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "800px") 

overstory_r %>% 
  filter(id %in% reconstruction_plots) %>%
  group_by(id, t_idxn) %>% 
  summarize(n = n(), date = first(date))

```


Now, we'll do the summary comparing the tree counts by quadrant. 
````{r by_quadrant}
# overstory_r: one tree per row. Need to put these into quadrants for counting
overstory_rq <- overstory_r %>% 
  mutate(quadrant = case_when(
    midline_dist_notes %in% c("NE", "SE", "SW", "NW") ~ midline_dist_notes, 
    x >= 90 & y >= 45 ~ "NE",
    x >= 90 & y < 45 ~ "SE",
    x < 90 & y < 45 ~ "SW",
    x < 90 & y >= 45 ~ "NW",
    # only two here and they are NA for x. just giving them a random quadrant. 
    .default = "NW" 
  )) 

overstory_rq %>% 
  filter(species != "POTR5") %>% 
  filter(id %in% reconstruction_plots) %>%
  group_by(id, t_idxn, quadrant) %>%
  summarise(ntrees = n(), .groups = "keep") %>%
  ungroup() %>%
  pivot_wider(names_from = c(t_idxn, quadrant), values_from = ntrees) %>% 
  rowwise %>%
  mutate(mean = mean(c_across(starts_with("P")), na.rm = TRUE),
         sd = sd(c_across(starts_with("P")), na.rm = TRUE),
         coef_variation = ifelse(mean == 0, NA, sd / mean)) %>%
  select(id, starts_with("PRE"), starts_with("POST_"), starts_with("POSTRX"),
         mean, coef_variation) %>%
  arrange(desc(coef_variation)) %>% 
  ungroup %>% 
  filter(id %in% reconstruction_plots) %>% 
  mutate(notes = case_when(
    id %in% high_aspen ~ ">30% aspen",
    .default = ""
  )) %>% 
  left_join(which_visit) %>% View
# check manually

````




```{r stump_plotL9}

# filter data 
data <- overstory %>%
  filter(id == "L9") #%>% 

data %>% 
  kbl() %>%
  kable_paper() %>%
  # row_spec(which(out2$t_idxn == "PRE_1" | out2$t_idxn == "PRE_2"), background = "#C7F9FF7F") %>% 
  scroll_box(width = "100%", height = "800px") 

# create the plot
ggplot(data, aes(x = x, y = y, fill = t_idxn, size = dbh, shape = stump)) +
  geom_point(alpha = 0.5) +
  labs(title = paste("Plot L9"),
       x = "Midline distance",
       y = "N/S distance") +
  theme_minimal() +
  coord_cartesian(xlim = c(-2, 166), ylim = c(-84, 84)) + 
  scale_shape_manual(values = c(22, 21)) +
  guides(fill=guide_legend(override.aes=list(shape=21))) 

```


# THE END

draft stuff below





```{r stump_plot3A}

# filter data 
data <- overstory %>%
  filter(id == "3A") %>% 
  mutate(stump = case_when(
    status == "S" ~ "Stump", 
    .default = "Tree"
  ))

# create the plot
ggplot(data, aes(x = x, y = y, fill = t_idxn, size = dbh, shape = stump)) +
  geom_point(alpha = 0.5) +
  labs(title = paste("Plot 3A"),
       x = "Midline distance",
       y = "N/S distance") +
  theme_minimal() +
  coord_cartesian(xlim = c(-2, 166), ylim = c(-84, 84)) + 
  scale_shape_manual(values = c(22, 21)) +
  guides(fill=guide_legend(override.aes=list(shape=21))) 

```

meeting notes

last meeting:
⦁	reviewed some plot id's and discussed whether they were unique. Wrote modified overstory.R script to correct specific id values.
⦁	reviewed DBH thresholds and...decided on a dbh cutoff of 8? Did we actually do that? I have an implementation of that but haven't put it into the "main" script. 
⦁	examined possibility of aspen regeneration effects on tree counts. Any todo on this one? NOTHING TO DO YET
⦁	next task was to examine stump data and use it to 'reconstruct' plots where possible.

work completed today:
⦁	updated Plot Mapper shiny app and main Rmd file to use data with corrected IDs

work still in progress:
⦁	fully implement DBH cutoff? YES DO THAT
⦁	implement fix for half/partial plots?

Focus on 2024 stump data in plots marked Reconstruction
plots should focus on "CFLRP" stumps, highlighting whether these stumps have matching trees in the PRE visit


this meeting:
⦁	where we have stump data
⦁		Remind me which stump data I should be looking at
⦁	some plots to make sense of it (???)
⦁		I think we probably need a better visualization, maybe interactive shiny app 




## Overview plots 

## Some simple statistical analyses to support the plots

```{r cars}
summary(cars)
```
